#!/bin/bash

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SEPOLIA RPC MANAGER - Fast Setup with Geth & Prysm
# Version: 2.0
# Description: Complete RPC node management (Debian/Ubuntu compatible)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Color definitions
CYAN='\033[0;36m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
WHITE='\033[1;37m'
AMBER='\033[0;33m'
PURPLE='\033[0;35m'
NC='\033[0m'
BOLD='\033[1m'
DIM='\033[2m'

# Configuration
RPC_DIR="/root/ethereum"
GETH_PORT=8545
WS_PORT=8546
BEACON_PORT=3500
LOG_FILE="/var/log/rpc-manager.log"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ERROR HANDLING & LOGGING SYSTEM
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Enable error handling
set -o pipefail

# Logging function
log() {
    local level=$1
    shift
    local message="$@"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $message" | sudo tee -a "$LOG_FILE" >/dev/null 2>&1
}

# Error handler
error_exit() {
    local message="$1"
    local line="${2:-unknown}"
    echo -e "\n${RED}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${RED}â•‘           âŒ ERROR OCCURRED                 â•‘${NC}"
    echo -e "${RED}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${RED}Error: ${message}${NC}"
    echo -e "${YELLOW}Line: ${line}${NC}"
    echo -e "${YELLOW}Check log: ${LOG_FILE}${NC}\n"
    log "ERROR" "$message (Line: $line)"
    read -p "Press Enter to return to menu..."
}

# Trap errors
trap 'error_exit "Script failed" "$LINENO"' ERR

# Cleanup on exit
cleanup_on_exit() {
    log "INFO" "Script exiting normally"
}
trap cleanup_on_exit EXIT

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DEPENDENCY CHECKS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

check_dependencies() {
    local missing_deps=()
    
    # Check for required commands
    command -v curl &>/dev/null || missing_deps+=("curl")
    command -v wget &>/dev/null || missing_deps+=("wget")
    command -v awk &>/dev/null || missing_deps+=("awk")
    command -v grep &>/dev/null || missing_deps+=("grep")
    
    if [ ${#missing_deps[@]} -gt 0 ]; then
        echo -e "${YELLOW}Installing missing dependencies: ${missing_deps[*]}${NC}"
        sudo apt update >/dev/null 2>&1
        sudo apt install -y "${missing_deps[@]}" >/dev/null 2>&1 || {
            error_exit "Failed to install dependencies"
            return 1
        }
    fi
    return 0
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HELPER FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

install_docker() {
    if ! command -v docker &> /dev/null; then
        echo -e "${YELLOW}Installing Docker...${NC}"
        log "INFO" "Starting Docker installation"
        
        # Check if Ubuntu or Debian
        if [ ! -f /etc/os-release ]; then
            error_exit "Not Ubuntu or Debian - unsupported OS"
            return 1
        fi
        
        # Update system
        sudo apt update -y && sudo apt upgrade -y || {
            error_exit "Failed to update system"
            return 1
        }
        
        # Install prerequisites
        sudo apt-get update
        sudo apt-get install -y ca-certificates curl gnupg lsb-release || {
            error_exit "Failed to install prerequisites"
            return 1
        }
        sudo install -m 0755 -d /etc/apt/keyrings
        
        # Add Docker's official GPG key
        . /etc/os-release
        repo_url="https://download.docker.com/linux/$ID"
        curl -fsSL "$repo_url/gpg" | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg || {
            error_exit "Failed to add Docker GPG key"
            return 1
        }
        sudo chmod a+r /etc/apt/keyrings/docker.gpg
        
        # Set up the repository
        echo \
          "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] $repo_url $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
          sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
        
        # Install Docker
        sudo apt update -y
        sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin || {
            error_exit "Failed to install Docker"
            return 1
        }
        
        # Test Docker installation
        if sudo docker run hello-world >/dev/null 2>&1; then
            sudo docker rm $(sudo docker ps -a --filter "ancestor=hello-world" --format "{{.ID}}") --force 2>/dev/null || true
            sudo docker image rm hello-world 2>/dev/null || true
            sudo systemctl enable docker
            sudo systemctl restart docker
            echo -e "${GREEN}âœ… Docker Installed Successfully${NC}"
            log "INFO" "Docker installed successfully"
        else
            error_exit "Docker installation test failed"
            return 1
        fi
    else
        echo -e "${GREEN}âœ… Docker is already installed${NC}"
        log "INFO" "Docker already installed"
    fi
}

check_docker() {
    if ! command -v docker &> /dev/null; then
        install_docker || return 1
    fi
}

get_public_ip() {
    local ip
    ip=$(curl -s --max-time 5 ipv4.icanhazip.com 2>/dev/null) || \
    ip=$(curl -s --max-time 5 ifconfig.me 2>/dev/null) || \
    ip=$(curl -s --max-time 5 api.ipify.org 2>/dev/null) || \
    ip="localhost"
    echo "$ip"
}

# Rollback function
rollback_installation() {
    echo -e "\n${YELLOW}Rolling back installation...${NC}"
    log "WARN" "Rolling back RPC installation"
    
    cd /root || return
    
    # Stop containers
    if [ -d "$RPC_DIR" ]; then
        cd "$RPC_DIR" || return
        sudo docker compose down 2>/dev/null || sudo docker-compose down 2>/dev/null || true
    fi
    
    # Remove containers
    sudo docker stop geth prysm 2>/dev/null || true
    sudo docker rm geth prysm 2>/dev/null || true
    
    # Remove directory
    sudo rm -rf "$RPC_DIR" 2>/dev/null || true
    
    echo -e "${GREEN}âœ… Rollback complete${NC}"
    log "INFO" "Rollback completed successfully"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

install_rpc() {
    clear
    echo -e "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${CYAN}â•‘        ðŸš€ INSTALL SEPOLIA RPC (GETH & PRYSM)         â•‘${NC}"
    echo -e "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    
    log "INFO" "Starting RPC installation"
    
    # Disable error trap temporarily for requirement checks
    set +e
    
    # Check minimum requirements
    RAM_GB=$(($(grep MemTotal /proc/meminfo | awk '{print $2}') / 1024 / 1024))
    CORES=$(nproc)
    STORAGE_GB=$(df -BG / | awk 'NR==2 {print $4}' | sed 's/G//')
    
    if [ "$RAM_GB" -lt 8 ] || [ "$CORES" -lt 2 ]; then
        echo -e "${RED}âš ï¸  Your VPS does not meet minimum requirements${NC}"
        echo -e "${WHITE}Current: RAM ${RAM_GB}GB, Cores ${CORES}${NC}"
        echo -e "${WHITE}Required: RAM 8GB+, Cores 2+${NC}"
        read -p "Continue anyway? (y/N): " cont
        if [[ ! "$cont" =~ ^[Yy]$ ]]; then
            log "INFO" "Installation cancelled - requirements not met"
            return
        fi
        log "WARN" "User proceeded despite not meeting requirements"
    fi
    
    # Check if already installed
    if [ -d "$RPC_DIR" ] && [ -f "$RPC_DIR/docker-compose.yml" ]; then
        echo -e "${YELLOW}âš ï¸  RPC already installed at $RPC_DIR${NC}"
        read -p "Do you want to reinstall? (y/N): " reinstall
        if [[ ! "$reinstall" =~ ^[Yy]$ ]]; then
            echo -e "${YELLOW}Installation cancelled${NC}"
            log "INFO" "Installation cancelled - already installed"
            read -p "Press Enter to continue..."
            return
        fi
        
        # Stop existing containers
        echo -ne "${CYAN}Stopping existing containers...${NC}"
        cd "$RPC_DIR" || { error_exit "Cannot access $RPC_DIR"; return 1; }
        sudo docker compose down 2>/dev/null || sudo docker-compose down 2>/dev/null || true
        cd ~ || return
        echo -e " ${GREEN}âœ“${NC}"
        log "INFO" "Stopped existing containers"
    fi
    
    # Re-enable error trap
    set -e
    
    # Install dependencies
    echo -ne "${CYAN}Installing dependencies...${NC}"
    if ! sudo apt update >/dev/null 2>&1; then
        error_exit "Failed to update package list"
        return 1
    fi
    
    if ! sudo apt install -y wget lz4 aria2 openssl docker-compose-plugin >/dev/null 2>&1; then
        echo -e " ${RED}âœ—${NC}"
        error_exit "Failed to install dependencies"
        rollback_installation
        return 1
    fi
    echo -e " ${GREEN}âœ“${NC}"
    log "INFO" "Dependencies installed"
    
    # Create directories
    echo -ne "${CYAN}Creating directories...${NC}"
    if ! sudo mkdir -p /root/ethereum/{execution,consensus}; then
        echo -e " ${RED}âœ—${NC}"
        error_exit "Failed to create directories"
        rollback_installation
        return 1
    fi
    echo -e " ${GREEN}âœ“${NC}"
    log "INFO" "Directories created"
    
    # Generate JWT secret
    echo -ne "${CYAN}Generating JWT secret...${NC}"
    if ! openssl rand -hex 32 | sudo tee /root/ethereum/jwt.hex > /dev/null; then
        echo -e " ${RED}âœ—${NC}"
        error_exit "Failed to generate JWT secret"
        rollback_installation
        return 1
    fi
    echo -e " ${GREEN}âœ“${NC}"
    log "INFO" "JWT secret generated"
    
    # Navigate to directory
    cd "$RPC_DIR" || { error_exit "Cannot access $RPC_DIR"; rollback_installation; return 1; }
    
    # Create docker-compose.yml
    echo -ne "${CYAN}Creating Docker configuration...${NC}"
    if ! sudo tee docker-compose.yml > /dev/null << 'EOF'
services:
  geth:
    image: ethereum/client-go:v1.16.4
    container_name: geth
    network_mode: host
    restart: unless-stopped
    volumes:
      - /root/ethereum/execution:/data
      - /root/ethereum/jwt.hex:/data/jwt.hex
    command:
      - --sepolia
      - --http
      - --http.api=eth,net,web3
      - --http.addr=0.0.0.0
      - --authrpc.addr=0.0.0.0
      - --authrpc.vhosts=*
      - --authrpc.jwtsecret=/data/jwt.hex
      - --authrpc.port=8551
      - --syncmode=snap
      - --datadir=/data
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  prysm:
    image: gcr.io/prysmaticlabs/prysm/beacon-chain:v6.1.2
    container_name: prysm
    network_mode: host
    restart: unless-stopped
    volumes:
      - /root/ethereum/consensus:/data
      - /root/ethereum/jwt.hex:/data/jwt.hex
    depends_on:
      - geth
    command:
      - --sepolia
      - --accept-terms-of-use
      - --datadir=/data
      - --disable-monitoring
      - --rpc-host=0.0.0.0
      - --execution-endpoint=http://127.0.0.1:8551
      - --jwt-secret=/data/jwt.hex
      - --rpc-port=4000
      - --grpc-gateway-corsdomain=*
      - --grpc-gateway-host=0.0.0.0
      - --grpc-gateway-port=3500
      - --min-sync-peers=3
      - --checkpoint-sync-url=https://checkpoint-sync.sepolia.ethpandaops.io
      - --genesis-beacon-api-url=https://checkpoint-sync.sepolia.ethpandaops.io
      - --subscribe-all-data-subnets
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
EOF
    then
        echo -e " ${RED}âœ—${NC}"
        error_exit "Failed to create docker-compose.yml"
        rollback_installation
        return 1
    fi
    echo -e " ${GREEN}âœ“${NC}"
    log "INFO" "Docker configuration created"
    
    # Start services
    echo -ne "${CYAN}Starting RPC services...${NC}"
    if ! sudo docker compose up -d >/dev/null 2>&1; then
        echo -e " ${RED}âœ—${NC}"
        echo -e "${RED}Failed to start services${NC}"
        log "ERROR" "Failed to start Docker services"
        echo -e "${YELLOW}Attempting rollback...${NC}"
        rollback_installation
        read -p "Press Enter to continue..."
        return 1
    fi
    echo -e " ${GREEN}âœ“${NC}"
    log "INFO" "Docker services started successfully"
    
    # Configure firewall
    echo -ne "${CYAN}Configuring firewall...${NC}"
    sudo ufw allow 22/tcp >/dev/null 2>&1 || true
    sudo ufw allow $GETH_PORT/tcp >/dev/null 2>&1 || true
    sudo ufw allow $WS_PORT/tcp >/dev/null 2>&1 || true
    sudo ufw allow $BEACON_PORT/tcp >/dev/null 2>&1 || true
    sudo ufw allow 30303/tcp >/dev/null 2>&1 || true
    sudo ufw allow 30303/udp >/dev/null 2>&1 || true
    sudo ufw allow 4000/tcp >/dev/null 2>&1 || true
    
    # Enable UFW if inactive
    if sudo ufw status 2>/dev/null | grep -q "Status: inactive"; then
        echo "y" | sudo ufw enable >/dev/null 2>&1 || true
    fi
    echo -e " ${GREEN}âœ“${NC}"
    log "INFO" "Firewall configured"
    
    # Get IP
    VPS_IP=$(get_public_ip)
    
    # Final message
    echo -e "\n${GREEN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${GREEN}â•‘              âœ… RPC INSTALLATION COMPLETE             â•‘${NC}"
    echo -e "${GREEN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo -e "${CYAN}ðŸ“Š RPC Endpoints:${NC}"
    echo -e "  ${WHITE}â€¢ HTTP RPC:${NC} ${YELLOW}http://$VPS_IP:$GETH_PORT${NC}"
    echo -e "  ${WHITE}â€¢ WebSocket:${NC} ${YELLOW}ws://$VPS_IP:$WS_PORT${NC}"
    echo -e "  ${WHITE}â€¢ Beacon API:${NC} ${YELLOW}http://$VPS_IP:$BEACON_PORT${NC}"
    echo ""
    echo -e "${YELLOW}â³ Sync time: 6-8 hours depending on your VPS specs${NC}"
    echo -e "\n${CYAN}Use option 2 to check sync progress${NC}"
    echo -e "${CYAN}Logs available at: ${LOG_FILE}${NC}"
    log "INFO" "RPC installation completed successfully"
    read -p "Press Enter to continue..."
}

check_sync() {
    clear
    echo -e "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${CYAN}â•‘              ðŸ“Š RPC SYNC STATUS CHECK                 â•‘${NC}"
    echo -e "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    
    log "INFO" "Checking sync status"
    
    # Disable error trap for checks
    set +e
    
    # Check if RPC is installed
    if [ ! -d "$RPC_DIR" ]; then
        echo -e "${RED}âŒ RPC not installed. Please install first (Option 1)${NC}"
        log "WARN" "Sync check failed - RPC not installed"
        read -p "Press Enter to continue..."
        return
    fi
    
    cd "$RPC_DIR" || return
    
    # Check if containers are running
    if ! sudo docker ps | grep -q "geth"; then
        echo -e "${RED}âŒ Geth container is not running${NC}"
        echo -e "${YELLOW}Starting containers...${NC}"
        log "WARN" "Geth not running, attempting to start"
        sudo docker compose up -d 2>/dev/null || sudo docker-compose up -d 2>/dev/null || {
            echo -e "${RED}Failed to start containers${NC}"
            log "ERROR" "Failed to start containers"
            read -p "Press Enter to continue..."
            return
        }
        sleep 5
    fi
    
    echo -e "${CYAN}Checking sync status...${NC}\n"
    
    # Check Geth sync
    echo -e "${WHITE}â•â•â•[ GETH STATUS ]â•â•â•${NC}"
    GETH_SYNC=$(curl -s --max-time 10 -X POST -H "Content-Type: application/json" \
        --data '{"jsonrpc":"2.0","method":"eth_syncing","params":[],"id":1}' \
        http://localhost:$GETH_PORT 2>/dev/null)
    
    if [ -z "$GETH_SYNC" ]; then
        echo -e "${RED}âŒ Cannot connect to Geth RPC${NC}"
        log "ERROR" "Cannot connect to Geth RPC"
    elif echo "$GETH_SYNC" | grep -q '"result":false'; then
        echo -e "${GREEN}âœ… Geth is fully synced${NC}"
        log "INFO" "Geth fully synced"
        
        # Get current block
        BLOCK=$(curl -s --max-time 5 -X POST -H "Content-Type: application/json" \
            --data '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}' \
            http://localhost:$GETH_PORT | grep -Po '"result":"\K[^"]*')
        
        if [ ! -z "$BLOCK" ]; then
            BLOCK_DEC=$((16#${BLOCK#0x}))
            echo -e "  ${WHITE}Current block:${NC} ${GREEN}$BLOCK_DEC${NC}"
        fi
    else
        echo -e "${YELLOW}â³ Geth is syncing...${NC}"
        log "INFO" "Geth syncing in progress"
        
        CURRENT=$(echo "$GETH_SYNC" | grep -Po '"currentBlock":"\K[^"]*')
        HIGHEST=$(echo "$GETH_SYNC" | grep -Po '"highestBlock":"\K[^"]*')
        
        if [ ! -z "$CURRENT" ] && [ ! -z "$HIGHEST" ]; then
            CURRENT_DEC=$((16#${CURRENT#0x}))
            HIGHEST_DEC=$((16#${HIGHEST#0x}))
            
            if [ $HIGHEST_DEC -gt 0 ]; then
                PROGRESS=$(awk "BEGIN {printf \"%.2f\", ($CURRENT_DEC/$HIGHEST_DEC)*100}")
                echo -e "  ${WHITE}Progress:${NC} ${YELLOW}${PROGRESS}%${NC}"
                echo -e "  ${WHITE}Current Block:${NC} $CURRENT_DEC"
                echo -e "  ${WHITE}Target Block:${NC} $HIGHEST_DEC"
                
                # Get ETA from Geth logs
                ETA=$(sudo docker logs geth --tail 20 2>&1 | grep -oP 'eta=\K[^ ]+' | tail -1)
                if [ ! -z "$ETA" ]; then
                    echo -e "  ${WHITE}Estimated time:${NC} ${YELLOW}${ETA}${NC}"
                fi
            fi
        fi
    fi
    
    # Check Prysm sync
    echo -e "\n${WHITE}â•â•â•[ PRYSM BEACON STATUS ]â•â•â•${NC}"
    BEACON_SYNC=$(curl -s --max-time 10 http://localhost:$BEACON_PORT/eth/v1/node/syncing 2>/dev/null)
    
    if [ -z "$BEACON_SYNC" ]; then
        echo -e "${RED}âŒ Cannot connect to Prysm Beacon${NC}"
        log "ERROR" "Cannot connect to Prysm Beacon"
    elif echo "$BEACON_SYNC" | grep -q '"is_syncing":false'; then
        echo -e "${GREEN}âœ… Beacon is fully synced${NC}"
        log "INFO" "Beacon fully synced"
    else
        echo -e "${YELLOW}â³ Beacon is syncing...${NC}"
        log "INFO" "Beacon syncing in progress"
        SYNC_DISTANCE=$(echo "$BEACON_SYNC" | grep -Po '"sync_distance":"\K[^"]*')
        if [ ! -z "$SYNC_DISTANCE" ]; then
            echo -e "  ${WHITE}Slots behind:${NC} ${YELLOW}$SYNC_DISTANCE${NC}"
        fi
    fi
    
    # Overall status
    echo -e "\n${WHITE}â•â•â•[ OVERALL STATUS ]â•â•â•${NC}"
    
    GETH_SYNCED=false
    BEACON_SYNCED=false
    
    if echo "$GETH_SYNC" | grep -q '"result":false'; then
        GETH_SYNCED=true
    fi
    
    if echo "$BEACON_SYNC" | grep -q '"is_syncing":false'; then
        BEACON_SYNCED=true
    fi
    
    if [ "$GETH_SYNCED" = true ] && [ "$BEACON_SYNCED" = true ]; then
        VPS_IP=$(get_public_ip)
        echo -e "${GREEN}âœ… RPC is fully synced and ready to use${NC}"
        echo -e "\n${CYAN}Your RPC URL for Aztec:${NC}"
        echo -e "${YELLOW}http://$VPS_IP:$GETH_PORT${NC}"
        log "INFO" "RPC fully synced and ready"
    else
        echo -e "${YELLOW}â³ RPC is still syncing. Please wait...${NC}"
    fi
    
    # Re-enable error trap
    set -e
    
    read -p "Press Enter to continue..."
}

view_rpc() {
    clear
    echo -e "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${CYAN}â•‘                 ðŸ“œ RPC CONNECTION INFO                â•‘${NC}"
    echo -e "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    
    # Disable error trap
    set +e
    
    if [ ! -d "$RPC_DIR" ]; then
        echo -e "${YELLOW}RPC is not installed${NC}"
        log "INFO" "Delete attempted but RPC not installed"
        read -p "Press Enter to continue..."
        return
    fi
    
    echo -e "${YELLOW}This will delete:${NC}"
    echo -e "  ${WHITE}â€¢ Geth container and data${NC}"
    echo -e "  ${WHITE}â€¢ Prysm container and data${NC}"
    echo -e "  ${WHITE}â€¢ All synced blockchain data${NC}"
    echo -e "  ${WHITE}â€¢ Directory: /root/ethereum${NC}"
    echo ""
    echo -e "${RED}âš ï¸  This action cannot be undone${NC}"
    read -p "Are you sure? [y/N]: " confirm
    
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        echo ""
        log "WARN" "User initiated RPC deletion"
        cd "$RPC_DIR" || cd ~ || return
        
        # Stop containers
        echo -ne "${CYAN}Stopping containers...${NC}"
        sudo docker compose down 2>/dev/null || sudo docker-compose down 2>/dev/null || true
        sudo docker stop geth prysm 2>/dev/null || true
        echo -e " ${GREEN}âœ“${NC}"
        
        # Remove containers
        echo -ne "${CYAN}Removing containers...${NC}"
        sudo docker rm geth prysm 2>/dev/null || true
        echo -e " ${GREEN}âœ“${NC}"
        
        # Remove images
        echo -ne "${CYAN}Removing Docker images...${NC}"
        sudo docker rmi ethereum/client-go:v1.16.4 2>/dev/null || true
        sudo docker rmi gcr.io/prysmaticlabs/prysm/beacon-chain:v6.1.2 2>/dev/null || true
        echo -e " ${GREEN}âœ“${NC}"
        
        # Remove data
        echo -ne "${CYAN}Removing RPC data...${NC}"
        cd ~ || return
        sudo rm -rf /root/ethereum 2>/dev/null || true
        echo -e " ${GREEN}âœ“${NC}"
        
        # Remove firewall rules
        echo -ne "${CYAN}Cleaning firewall rules...${NC}"
        sudo ufw delete allow 8545/tcp 2>/dev/null || true
        sudo ufw delete allow 8546/tcp 2>/dev/null || true
        sudo ufw delete allow 3500/tcp 2>/dev/null || true
        sudo ufw delete allow 4000/tcp 2>/dev/null || true
        sudo ufw delete allow 30303/tcp 2>/dev/null || true
        sudo ufw delete allow 30303/udp 2>/dev/null || true
        echo -e " ${GREEN}âœ“${NC}"
        
        echo -e "\n${GREEN}âœ… RPC Node completely deleted${NC}"
        log "INFO" "RPC Node deleted successfully"
    else
        echo -e "\n${CYAN}âŒ Deletion cancelled${NC}"
        log "INFO" "RPC deletion cancelled by user"
    fi
    
    # Re-enable error trap
    set -e
    
    read -p "Press Enter to continue..."
}

# Main menu
main_menu() {
    while true; do
        clear
        
        # Disable error trap for menu
        set +e
        
        # Get system specs
        RAM_GB=$(($(grep MemTotal /proc/meminfo | awk '{print $2}') / 1024 / 1024))
        CORES=$(nproc)
        STORAGE_GB=$(df -BG / | awk 'NR==2 {print $2}' | sed 's/G//')
        STORAGE_FREE=$(df -BG / | awk 'NR==2 {print $4}' | sed 's/G//')
        
        echo -e "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
        echo -e "${CYAN}â•‘          ðŸŒ SEPOLIA RPC NODE MANAGER                  â•‘${NC}"
        echo -e "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
        echo -e "${WHITE}    Fast Ethereum Sepolia RPC with Geth & Prysm${NC}"
        echo -e "${AMBER}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\n"
        
        # Display requirements
        echo -e "${YELLOW}ðŸ“‹ System Status:${NC}"
        echo ""
        echo -e "  ${WHITE}RAM:${NC}     Required: 16GB   â”‚   ${GREEN}You have: ${RAM_GB}GB${NC}"
        echo -e "  ${WHITE}Cores:${NC}   Required: 4      â”‚   ${GREEN}You have: ${CORES}${NC}"
        echo -e "  ${WHITE}Storage:${NC} Required: 1TB    â”‚   ${GREEN}Total: ${STORAGE_GB}GB | Free: ${STORAGE_FREE}GB${NC}"
        echo ""
        
        # Quick status
        echo -e "${WHITE}RPC Status:${NC}"
        if [ -d "$RPC_DIR" ] && sudo docker ps 2>/dev/null | grep -q "geth"; then
            echo -e "${GREEN}â— Installed and Running${NC}"
        elif [ -d "$RPC_DIR" ]; then
            echo -e "${YELLOW}â— Installed but Stopped${NC}"
        else
            echo -e "${RED}â— Not Installed${NC}"
        fi
        
        echo -e "\n${PURPLE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•[ ${WHITE}MENU OPTIONS${NC} ${PURPLE}]â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
        echo -e "  ${CYAN}[${WHITE}1${CYAN}]${NC} ${WHITE}ðŸš€ Install RPC (Geth & Prysm)${NC}"
        echo -e "  ${CYAN}[${WHITE}2${CYAN}]${NC} ${WHITE}ðŸ“Š Sync Checkup${NC}"
        echo -e "  ${CYAN}[${WHITE}3${CYAN}]${NC} ${WHITE}ðŸ“œ RPC Connection Info & Logs${NC}"
        echo -e "  ${CYAN}[${WHITE}4${CYAN}]${NC} ${WHITE}ðŸ—‘ï¸  Delete RPC Node${NC}"
        echo -e "  ${CYAN}[${WHITE}5${CYAN}]${NC} ${WHITE}ðŸšª Exit${NC}"
        
        echo -e "\n${AMBER}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        read -p "Select option [1-5]: " choice
        
        # Re-enable error trap
        set -e
        
        case $choice in
            1)
                install_rpc
                ;;
            2)
                check_sync
                ;;
            3)
                view_rpc
                ;;
            4)
                delete_rpc
                ;;
            5)
                echo -e "\n${CYAN}Thanks for using RPC Manager!${NC}"
                echo -e "${WHITE}Goodbye ðŸ‘‹${NC}\n"
                log "INFO" "Script exited by user"
                exit 0
                ;;
            *)
                echo -e "${RED}Invalid option. Please choose between 1-5.${NC}"
                sleep 2
                ;;
        esac
    done
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN EXECUTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Create log file if doesn't exist
sudo touch "$LOG_FILE" 2>/dev/null || LOG_FILE="/tmp/rpc-manager.log"
sudo chmod 666 "$LOG_FILE" 2>/dev/null || true

log "INFO" "==================== Script Started ===================="

# Check dependencies
check_dependencies || {
    echo -e "${RED}Failed to check/install dependencies${NC}"
    exit 1
}

# Check Docker on startup
check_docker || {
    echo -e "${RED}Docker check/installation failed${NC}"
    exit 1
}

# Start main menu
main_menu

# Script ends here naturally
